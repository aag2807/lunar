package main

import (
	"bufio"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

const version = "1.0.0"

func main() {
	outputFile := flag.String("o", "", "Output declaration file (default: input.d.lunar)")
	showVersion := flag.Bool("version", false, "Show version information")
	showHelp := flag.Bool("help", false, "Show help message")

	flag.Parse()

	if *showVersion {
		fmt.Printf("lunar2decl version %s\n", version)
		os.Exit(0)
	}

	if *showHelp {
		printHelp()
		os.Exit(0)
	}

	args := flag.Args()
	if len(args) < 1 {
		fmt.Fprintln(os.Stderr, "Error: No input file specified")
		fmt.Fprintln(os.Stderr, "Usage: lunar2decl [options] <input.lua>")
		fmt.Fprintln(os.Stderr, "Run 'lunar2decl --help' for more information")
		os.Exit(1)
	}

	inputFile := args[0]

	// Validate input file exists
	if _, err := os.Stat(inputFile); os.IsNotExist(err) {
		fmt.Fprintf(os.Stderr, "Error: Input file '%s' does not exist\n", inputFile)
		os.Exit(1)
	}

	// Determine output file
	output := *outputFile
	if output == "" {
		base := filepath.Base(inputFile)
		name := strings.TrimSuffix(base, filepath.Ext(base))
		output = name + ".d.lunar"
	}

	// Generate declarations
	if err := generateDeclarations(inputFile, output); err != nil {
		fmt.Fprintf(os.Stderr, "Generation failed:\n%v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s from %s\n", output, inputFile)
}

// generateDeclarations generates .d.lunar file from Lua source
func generateDeclarations(inputFile, outputFile string) error {
	source, err := ioutil.ReadFile(inputFile)
	if err != nil {
		return fmt.Errorf("failed to read input file: %w", err)
	}

	declarations := extractDeclarations(string(source))

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("-- Type declarations generated from %s\n", filepath.Base(inputFile)))
	sb.WriteString(fmt.Sprintf("-- Generated by lunar2decl %s\n", version))
	sb.WriteString("\n")

	// Write function declarations
	for _, decl := range declarations.Functions {
		sb.WriteString(decl)
		sb.WriteString("\n")
	}

	// Write global variable declarations
	if len(declarations.Globals) > 0 {
		sb.WriteString("\n-- Global variables\n")
		for _, glob := range declarations.Globals {
			sb.WriteString(glob)
			sb.WriteString("\n")
		}
	}

	if err := ioutil.WriteFile(outputFile, []byte(sb.String()), 0644); err != nil {
		return fmt.Errorf("failed to write output file: %w", err)
	}

	return nil
}

type Declarations struct {
	Functions []string
	Globals   []string
}

// extractDeclarations extracts function and variable declarations from Lua source
func extractDeclarations(source string) *Declarations {
	decls := &Declarations{
		Functions: []string{},
		Globals:   []string{},
	}

	// Pattern for global function: function name(params)
	funcPattern := regexp.MustCompile(`(?m)^function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*?)\)`)

	// Pattern for local function: local function name(params)
	localFuncPattern := regexp.MustCompile(`(?m)^local\s+function\s+([a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*?)\)`)

	// Pattern for module.function: function module.name(params)
	moduleFuncPattern := regexp.MustCompile(`(?m)^function\s+([a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*)\s*\((.*?)\)`)

	scanner := bufio.NewScanner(strings.NewReader(source))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())

		// Skip comments
		if strings.HasPrefix(line, "--") {
			continue
		}

		// Skip module.function pattern (requires interface declarations)
		if moduleFuncPattern.MatchString(line) {
			continue
		}

		// Check for local function (don't export these)
		if localFuncPattern.MatchString(line) {
			continue
		}

		// Check for global function
		if matches := funcPattern.FindStringSubmatch(line); matches != nil {
			name := matches[1]
			params := matches[2]
			decl := generateFunctionDeclaration(name, params)
			decls.Functions = append(decls.Functions, decl)
		}
	}

	return decls
}

// generateFunctionDeclaration generates a declare function statement
func generateFunctionDeclaration(name string, params string) string {
	// Parse parameters
	paramList := strings.Split(params, ",")
	var lunarParams []string

	for i, param := range paramList {
		param = strings.TrimSpace(param)
		if param == "" {
			continue
		}
		// Remove default values or varargs
		param = strings.Split(param, "=")[0]
		param = strings.TrimSpace(param)
		if param == "..." {
			param = fmt.Sprintf("arg%d: any", i+1)
		} else {
			param = fmt.Sprintf("%s: any", param)
		}
		lunarParams = append(lunarParams, param)
	}

	paramStr := strings.Join(lunarParams, ", ")
	return fmt.Sprintf("declare function %s(%s): any end", name, paramStr)
}

// printHelp prints help information
func printHelp() {
	fmt.Println("lunar2decl - Generate Lunar declaration files from Lua code")
	fmt.Printf("Version: %s\n\n", version)
	fmt.Println("Usage:")
	fmt.Println("  lunar2decl [options] <input.lua>")
	fmt.Println()
	fmt.Println("Options:")
	fmt.Println("  -o <file>        Output declaration file (default: input.d.lunar)")
	fmt.Println("  --version        Show version information")
	fmt.Println("  --help           Show this help message")
	fmt.Println()
	fmt.Println("Examples:")
	fmt.Println("  lunar2decl mylib.lua")
	fmt.Println("  lunar2decl mylib.lua -o declarations.d.lunar")
	fmt.Println()
	fmt.Println("Description:")
	fmt.Println("  Analyzes Lua source files and generates corresponding .d.lunar")
	fmt.Println("  declaration files with function signatures. This helps create")
	fmt.Println("  type declarations for existing Lua libraries.")
	fmt.Println()
	fmt.Println("  Generated declarations use 'any' type by default. You should")
	fmt.Println("  manually refine the types for better type safety.")
}
